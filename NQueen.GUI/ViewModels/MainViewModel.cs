#nullable enable

namespace NQueen.GUI.ViewModels;

public sealed partial class MainViewModel : ObservableObject, IDisposable
{
    public MainViewModel(IDispatcher uiDispatcher) :
        this(new BackTrackingSolver(new SolutionManager()), uiDispatcher)
    { }

    public MainViewModel(ISolver solver, IDispatcher dispatcher)
    {
        _uiDispatcher = dispatcher
            ?? throw new ArgumentNullException(nameof(dispatcher));
        
        Solver = solver ??
            throw new ArgumentNullException(nameof(solver));

        // Initialize commands directly
        SimulateCommand = new RelayCommand(Simulate, CanSimulate);
        SaveCommand = new RelayCommand(Save, CanSave);
        CancelCommand = new RelayCommand(Cancel, CanCancel);

        ObservableSolutions = [];
        Initialize();
        SubscribeToSimulationEvents();
    }

    private void InitializeCommands()
    {
        SimulateCommand = new RelayCommand(Simulate, CanSimulate);
        SaveCommand = new RelayCommand(Save, CanSave);
        CancelCommand = new RelayCommand(Cancel, CanCancel);
    }

    public IRelayCommand SimulateCommand { get; private set; }

    public IRelayCommand SaveCommand { get; private set; }

    public IRelayCommand CancelCommand { get; private set; }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    private void Dispose(bool disposing)
    {
        if (_disposed)
            return;

        if (disposing)
        {
            // Dispose managed resources
            CancelationTokenSource?.Dispose();
            CancelationTokenSource = null;

            // Clear collections
            ObservableSolutions.Clear();
            Chessboard?.Squares.Clear();
        }

        // Dispose unmanaged resources
        _disposed = true;
    }

    private void Initialize(int boardSize = BoardSettings.DefaultBoardSize,
        SolutionMode solutionMode = SimulationSettings.DefaultSolutionMode,
        DisplayMode displayMode = SimulationSettings.DefaultDisplayMode)
    {
        InputViewModel = new InputViewModel { ClassLevelCascadeMode = CascadeMode.Stop };
        BoardSize = boardSize;
        BoardSizeText = boardSize.ToString();
        SolutionMode = solutionMode;
        DisplayMode = displayMode;

        IsIdle = true;
        IsInInputMode = true;
        IsSimulating = false;
        IsOutputReady = false;
        NoOfSolutions = $"{ObservableSolutions.Count,0:N0}";

        DelayInMilliseconds = SimulationSettings.DefaultDelayInMilliseconds;
        ProgressVisibility = Visibility.Hidden;
        ProgressLabelVisibility = Visibility.Hidden;

        // Initialize the chessboard
        Chessboard = new Chessboard(_uiDispatcher);
    }

    private void UpdateGui()
    {
        ObservableSolutions.Clear();
        Chessboard?.Squares.Clear();
        BoardSize = int.Parse(BoardSizeText);
        NoOfSolutions = "0";
        ElapsedTimeInSec = $"{0,0:N1}";
        MemoryUsage = "0";
        Chessboard?.CreateSquares(BoardSize, []);
    }

    private void UpdateButtonFunctionality()
    {
        SimulateCommand?.NotifyCanExecuteChanged();
        CancelCommand?.NotifyCanExecuteChanged();
        SaveCommand?.NotifyCanExecuteChanged();
    }

    private void ExtractCorrectNoOfSols()
    {
        // Ensure previous solutions are cleared before adding new ones
        ObservableSolutions.Clear();

        var sols = SimulationResults
            .Solutions
            .Take(SimulationSettings.MaxNoOfSolutionsInOutput);

        if (DisplayMode == DisplayMode.Visualize)
        {
            foreach (var s in sols)
                ObservableSolutions.Add(s);

            return;
        }

        StringBuilder sb = new();
        foreach (var s in sols)
        {
            sb.Append(s.ToString());
            sb.Append(Environment.NewLine);
            ObservableSolutions.Add(s);
        }

        // If you need to use the concatenated string for some purpose
        _ = sb.ToString();
    }

    private async Task SimulateAsync()
    {
        try
        {
            // Update the simulation status to Started
            ManageSimulationStatus(SimulationStatus.Started);

            // Update the GUI before starting the simulation
            UpdateGui();

            // Run the solver to get simulation results
            SimulationResults = await Solver.GetResultsAsync(BoardSize, SolutionMode, DisplayMode);

            // Check if the solver returned valid results
            if (SimulationResults == null || !SimulationResults.Solutions.Any())
            {
                throw new InvalidOperationException("No solutions were generated by the solver.");
            }

            // Process the results and update the UI
            ExtractCorrectNoOfSols();
            NoOfSolutions = $"{SimulationResults.NoOfSolutions,0:N0}";
            ElapsedTimeInSec = $"{SimulationResults.ElapsedTimeInSec,0:N1}";

            // Fix for CS7036: Provide the required arguments for the Solution constructor.  
            SelectedSolution = ObservableSolutions.FirstOrDefault() ?? new Solution([], null);

            // Debugging output
            Console.WriteLine($"NoOfSolutions: {NoOfSolutions}, ElapsedTimeInSec: {ElapsedTimeInSec}");
        }
        catch (Exception ex)
        {
            // Log the error and rethrow it
            Console.WriteLine($"Error during simulation: {ex.Message}");
            throw;
        }
        finally
        {
            // Update the simulation status to Finished
            ManageSimulationStatus(SimulationStatus.Finished);
        }
    }

    private readonly IDispatcher _uiDispatcher;
}

#nullable restore